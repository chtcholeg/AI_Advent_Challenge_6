# Day 13 - Telegram Channel Reminders with Local Tools

This document describes the changes between Day 12 (MCP Stability & Bug Fixes) and Day 13 (Telegram Channel Reminders).

## Overview

Day 13 introduces **Local Tool Integration** - a new capability allowing tools to execute directly inside the application without requiring external MCP servers. The flagship feature is **Telegram Channel Reminders**, which provides automatic monitoring and AI-powered summarization of Telegram channels at configurable intervals.

## Key Innovations

### 1. Two-Level Tool System

Previous architecture (Day 11-12):
- All tools executed via external MCP servers
- Tool routing: AI → ChatRepository → McpRepository → External Server

New architecture (Day 13):
- **Local Tools**: Execute directly in the app (in-process)
- **MCP Tools**: Execute via external servers (out-of-process)
- Tool routing: AI → ChatRepository → **LocalToolHandler** (local) OR McpRepository (MCP)
- Both tool types presented to AI as unified function calling API

### 2. Local Tool Execution

**Benefits over MCP tools:**
- ✅ No external server setup required
- ✅ Lower latency (no network round-trips)
- ✅ Direct access to app state (ReminderStore, Database)
- ✅ Simplified configuration (no stdio/HTTP transport)
- ✅ Better error handling and validation

**Architecture:**
```
AI Request with Tools
  ↓
ChatRepositoryImpl.sendMessage()
  ↓
[Merge Local Tools + MCP Tools into single array]
  ↓
AI Response with function_call
  ↓
executeFunctionCall()
  ↓
  ├─→ if (toolName in LOCAL_TOOL_NAMES)
  │     └─→ LocalToolHandler.execute()
  │           └─→ ReminderStore.dispatch(Intent)
  │
  └─→ else
        └─→ McpRepository.executeTool()
              └─→ External MCP Server
```

## New Features

### 1. Telegram Channel Monitoring

**User Experience:**
- Natural language commands: "Monitor @durov every 30 seconds"
- Automatic summarization of new messages using AI
- Background execution independent of UI
- Persistent configuration across app restarts

**Technical Implementation:**
- **ReminderStore**: MVI store with coroutine-based tick loop
- **ReminderConfig**: Domain model with validation (channel, interval, messageCount, enabled, sessionId, lastSeenMessageId)
- **ReminderInterval**: Enum with 7 predefined intervals (10s, 30s, 1m, 5m, 10m, 30m, 1h)
- **ReminderLocalRepository**: SQLDelight-based persistent storage

**Execution Flow:**
```
Every N seconds:
  1. Fetch messages via MCP tool: get_channel_messages(channel, count)
  2. Extract max message ID from result
  3. Compare with lastSeenMessageId (skip if same)
  4. Generate summary via AI with custom system prompt
  5. Update lastSeenMessageId and lastTriggeredAt
  6. Update ReminderState with summary
  7. Display as REMINDER message in chat
```

### 2. Three Local Tools

#### setup_reminder
Configure periodic monitoring with parameters:
- `channel` (string): Telegram channel username (with or without @)
- `interval_seconds` (integer): Check interval (10, 30, 60, 300, 600, 1800, 3600)
- `message_count` (integer, optional): Messages to fetch (1-30, default 10)

**Example prompts:**
- "Monitor @durov channel every 30 seconds"
- "Track @techcrunch every 5 minutes with last 10 messages"

#### update_reminder
Modify active reminder parameters:
- `field` (string): Parameter to change (channel, interval_seconds, message_count)
- `value` (string): New value (auto-parsed)

**Example prompts:**
- "Increase check interval to 10 minutes"
- "Switch to @python channel"
- "Get 20 messages instead of 10"

#### stop_reminder
Stop active monitoring (no parameters).

**Example prompts:**
- "Stop monitoring"
- "Turn off reminder"

### 3. Smart Deduplication

**Problem:** Avoid re-processing the same messages on every tick.

**Solution:**
- Extract message IDs from MCP tool result: `ID: 12345`
- Find max message ID in batch
- Compare with `lastSeenMessageId` from database
- Skip summarization if IDs match
- Update `lastSeenMessageId` after processing

**Benefits:**
- Reduces unnecessary AI API calls
- Saves tokens and execution time
- Only processes genuinely new messages

### 4. REMINDER Message Type

New `MessageType.REMINDER` for displaying channel summaries in chat UI:
```kotlin
enum class MessageType {
    USER,
    AI,
    SYSTEM,
    REMINDER  // NEW in Day 13
}
```

**Characteristics:**
- Not sent to AI in conversation history (UI-only, like SYSTEM messages)
- Displayed with distinct styling in MessageList
- Contains summarized content from monitored channels
- Includes metadata (channel name, timestamp)

### 5. TelegramMCPServer Integration

**Server Capabilities:**
- **get_channel_messages**: Fetch last N messages from public Telegram channel
  - Returns: message text (up to 500 chars), date, views, media flag, reply info
- **get_channel_info**: Get channel metadata (title, description, member count, verification status)

**Authentication:**
- One-time OTP setup creates persistent Telegram session
- Session file (`telegram_session.session`) reused for all requests
- No per-request authentication required

**Setup Process:**
```bash
# 1. Get API credentials from https://my.telegram.org
# 2. Run one-time session setup
cd TelegramMCPServer
pip install -r requirements.txt
TELEGRAM_API_ID=xxx TELEGRAM_API_HASH=xxx python setup_session.py

# 3. Start server
TELEGRAM_API_ID=xxx TELEGRAM_API_HASH=xxx python main.py --no-auth

# 4. Add in GigaChat app Settings → MCP Servers
# Name: Telegram MCP
# Type: HTTP
# URL: http://localhost:8000/sse
```

## Code Changes

### New Files

**Domain Layer:**
- `domain/model/ReminderConfig.kt`: Domain model for reminder configuration
  - Fields: id, channel, interval (enum), messageCount, enabled, sessionId, lastSeenMessageId, lastTriggeredAt, createdAt

**Data Layer:**
- `data/local/ReminderLocalRepository.kt`: Interface for persistent reminder storage
- `data/local/ReminderLocalRepositoryImpl.kt`: Implementation using SQLDelight queries
- `data/tool/LocalToolHandler.kt`: Local tool execution handler
  - Contains tool definitions with schemas and few-shot examples
  - Routes tool calls to appropriate handler methods
  - Returns McpToolResult for consistency

**Presentation Layer:**
- `presentation/reminder/ReminderStore.kt`: MVI store for reminder lifecycle
  - Init: Load active reminder from DB and start tick loop
  - Background coroutine: Executes periodic channel checks
  - Intent handlers: Start, Stop, UpdateConfig, Activate
- `presentation/reminder/ReminderState.kt`: UI state (activeConfig, lastSummary, lastSummaryChannel, error)
- `presentation/reminder/ReminderIntent.kt`: User actions (Start, Stop, UpdateConfig, Activate)

**Database:**
- `sqldelight/ru/chtcholeg/app/data/local/Reminder.sq`: SQL schema and queries
  - Table: ReminderEntity with 9 columns
  - Queries: selectActive, selectBySessionId, upsert, updateLastSeen, disable, deleteById

**External:**
- `TelegramMCPServer/` directory (UPDATED): Full-featured Telegram MCP server
  - `main.py`: FastAPI server with SSE transport
  - `telegram_client.py`: Telethon wrapper for Telegram API
  - `tools.py`: Tool implementations (get_channel_messages, get_channel_info)
  - `setup_session.py`: One-time interactive OTP authentication
  - `README.md`: Comprehensive server documentation

### Modified Files

**ChatRepositoryImpl.kt:**
```kotlin
// BEFORE (Day 12):
val functions = if (mcpTools.isNotEmpty()) {
    convertMcpToolsToFunctions(mcpTools)
} else {
    null
}

// AFTER (Day 13):
val mcpFunctions = if (mcpTools.isNotEmpty())
    convertMcpToolsToFunctions(mcpTools)
else emptyList()
val allFunctions = mcpFunctions + LocalToolHandler.LOCAL_TOOL_DEFINITIONS
val functions = allFunctions.ifEmpty { null }
```

```kotlin
// BEFORE (Day 12):
val toolResult = mcpRepository.executeTool(functionCall.name, parameters)

// AFTER (Day 13):
val toolResult = if (functionCall.name in LocalToolHandler.TOOL_NAMES) {
    localToolHandler.execute(functionCall.name, parameters, currentSessionId = null)
} else {
    mcpRepository.executeTool(functionCall.name, parameters)
}
```

```kotlin
// BEFORE (Day 12):
ru.chtcholeg.app.domain.model.MessageType.SYSTEM -> {
    // Skip SYSTEM messages
}

// AFTER (Day 13):
ru.chtcholeg.app.domain.model.MessageType.SYSTEM,
ru.chtcholeg.app.domain.model.MessageType.REMINDER -> {
    // Skip SYSTEM/REMINDER messages
}
```

**ChatMessage.kt:**
```kotlin
enum class MessageType {
    USER,
    AI,
    SYSTEM,
    REMINDER  // NEW in Day 13
}
```

**Koin.kt:**
```kotlin
// Added to appModule:
single { ReminderLocalRepositoryImpl(get()) }
single { LocalToolHandler(reminderStoreProvider = { get() }) }
single {
    ReminderStore(
        mcpRepository = get(),
        chatRepository = get(),
        reminderLocalRepository = get(),
        coroutineScope = CoroutineScope(Dispatchers.Default + SupervisorJob())
    )
}

// Updated ChatRepositoryImpl injection:
single<ChatRepository> {
    ChatRepositoryImpl(
        httpClient = get(),
        gigaChatClientId = BuildKonfig.GIGACHAT_CLIENT_ID,
        gigaChatClientSecret = BuildKonfig.GIGACHAT_CLIENT_SECRET,
        huggingFaceToken = BuildKonfig.HUGGINGFACE_API_TOKEN,
        settingsRepository = get(),
        mcpRepository = get(),
        localToolHandler = get()  // NEW dependency
    )
}
```

## Database Schema Changes

### New Table: ReminderEntity

```sql
CREATE TABLE ReminderEntity (
    id TEXT NOT NULL PRIMARY KEY,
    channel TEXT NOT NULL,
    intervalSeconds INTEGER NOT NULL DEFAULT 30,
    messageCount INTEGER NOT NULL DEFAULT 10,
    enabled INTEGER NOT NULL DEFAULT 1,
    sessionId TEXT,
    createdAt INTEGER NOT NULL,
    lastTriggeredAt INTEGER,
    lastSeenMessageId TEXT
);
```

**Queries:**
- `selectActive`: Get the single active reminder (LIMIT 1)
- `selectBySessionId`: Get reminder linked to specific chat session
- `upsert`: INSERT OR REPLACE for SQLite 3.18 compatibility
- `updateLastSeen`: Update lastSeenMessageId and lastTriggeredAt after tick
- `disable`: Set enabled=0 without deleting
- `deleteById`: Permanently remove reminder

## Migration Guide

### For Users

1. **Update to Day 13 build**:
   ```bash
   git pull
   ./gradlew clean build
   ```

2. **Set up TelegramMCPServer** (if using reminders):
   - Get Telegram API credentials from https://my.telegram.org
   - Run `setup_session.py` for one-time authentication
   - Start server with `python main.py --no-auth`
   - Add server in app Settings → MCP Servers

3. **Try reminders**:
   - "Monitor @durov every 30 seconds"
   - Wait for first summary to appear
   - "Increase interval to 5 minutes"
   - "Stop monitoring"

### For Developers

1. **Adding new local tools**:
   ```kotlin
   // 1. Add to LOCAL_TOOL_DEFINITIONS in LocalToolHandler.kt
   GigaChatFunction(
       name = "my_tool",
       description = "Tool description for AI",
       parameters = buildJsonObject { /* schema */ },
       fewShotExamples = listOf(/* examples */)
   )

   // 2. Add name to TOOL_NAMES set
   val TOOL_NAMES = setOf("setup_reminder", "update_reminder", "stop_reminder", "my_tool")

   // 3. Implement handler in execute()
   when (toolName) {
       "my_tool" -> handleMyTool(args)
       // ...
   }
   ```

2. **Database regeneration**:
   ```bash
   ./gradlew generateCommonMainChatDatabaseInterface
   ```

3. **Testing reminders**:
   - Use 10-second interval for quick testing
   - Monitor low-traffic channels to avoid rate limits
   - Check logs for tick execution and summary generation

## Breaking Changes

None. Day 13 is fully backward compatible with Day 12.

## Known Limitations

1. **One Active Reminder**: Only one reminder can be active at a time
2. **Public Channels Only**: Private channels require membership
3. **Message Truncation**: Messages limited to 500 characters in MCP tool response
4. **Rate Limiting**: Telegram API has rate limits (FloodWaitError)
5. **Session Expiration**: Telegram sessions can expire (rare, but requires re-authentication)

## Performance Impact

- **Memory**: +~50KB for ReminderStore and cached configuration
- **CPU**: Minimal (periodic coroutine wakeup every N seconds)
- **Battery**: Negligible (lightweight HTTP requests)
- **Storage**: +~1KB per reminder configuration in database

## Security Considerations

- **Telegram Session File**: Contains authentication tokens, should be protected (not committed to git)
- **API Credentials**: Stored in .env or environment variables, never hardcoded
- **MCP Server Auth**: Use `MCP_API_KEY` and `X-API-Key` header for production deployments
- **Local Tool Validation**: All parameters validated before execution

## Future Enhancements

Potential improvements for future days:
- [ ] Multiple simultaneous reminders
- [ ] Reminder scheduling (specific times/days)
- [ ] Custom summarization prompts per channel
- [ ] Message filtering by keywords
- [ ] Reminder notifications (push/desktop)
- [ ] Export summaries to file
- [ ] Reminder statistics and analytics
- [ ] Support for private channels (via membership)

## Documentation Updates

- ✅ `CLAUDE.md`: Added Day 13 section, Reminder Components, Local Tool Integration guide
- ✅ `README.md`: Added Day 13 overview, usage guide, troubleshooting
- ✅ `TelegramMCPServer/README.md`: Comprehensive server documentation (setup, tools, examples)
- ✅ `DIFF_12-13.md`: This file

## Testing Checklist

Day 13 testing scenarios:

- [x] Set up Telegram MCP server with OTP authentication
- [x] Add Telegram MCP server in app Settings
- [x] Create reminder with "Monitor @durov every 30 seconds"
- [x] Verify reminder appears in database (ReminderEntity table)
- [x] Wait for first summary to appear as REMINDER message
- [x] Verify deduplication (no duplicate summaries for same messages)
- [x] Update interval with "Increase to 5 minutes"
- [x] Update channel with "Switch to @python"
- [x] Update message count with "Get 20 messages"
- [x] Stop reminder with "Stop monitoring"
- [x] Verify reminder disabled in database (enabled=0)
- [x] Restart app and verify active reminder resumes
- [x] Test error handling (invalid channel name, server offline)
- [x] Test with different intervals (10s, 1m, 5m, 10m, 30m, 1h)
- [x] Verify local tools and MCP tools work together

## Conclusion

Day 13 successfully introduces **Local Tool Integration** as a powerful new capability alongside existing MCP tool support. The two-level tool system (local + MCP) provides flexibility: simple tools run in-app for lower latency, while complex tools delegate to external servers for specialized functionality.

**Telegram Channel Reminders** demonstrates the practical value of this architecture by combining:
- Local tool execution (setup/update/stop reminder)
- MCP tool integration (fetch Telegram messages)
- AI summarization (generate human-readable summaries)
- Persistent storage (SQLDelight database)
- Background processing (coroutine tick loop)

This creates a seamless user experience: "Monitor @channel every 5 minutes" → automatic AI-powered summaries delivered to your chat. The foundation is now in place for many more local tool use cases in future days.
